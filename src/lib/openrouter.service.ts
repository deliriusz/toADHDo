import { z } from "zod";
import type {
  ChatCompletionRequest,
  ChatCompletionResponse,
  ModelParameters,
  OpenRouterConfig,
  RequestPayload,
} from "./openrouter.types";
import { NetworkError, APIError, ValidationError, TimeoutError, responseSchema } from "./openrouter.types";

/**
 * Service for interacting with OpenRouter API
 */
export class OpenRouterService {
  private openRouterConfig: OpenRouterConfig;
  private httpClientInstance: typeof fetch;
  private schemaValidator: z.ZodType<ChatCompletionResponse>;

  /**
   * Creates a new instance of OpenRouterService
   */
  constructor({
    apiKey,
    baseURL = "https://openrouter.ai/api/v1/chat/completions",
    defaultModel = "gpt-4o-mini",
    modelParams = { temperature: 0.7, max_tokens: 500 },
    defaultSystemMessage = "",
  }: {
    apiKey: string;
    baseURL?: string;
    defaultModel?: string;
    modelParams?: ModelParameters;
    defaultSystemMessage?: string;
  }) {
    if (!apiKey) {
      throw new Error("OpenRouter API key is required");
    }

    this.openRouterConfig = {
      apiKey,
      baseURL,
      defaultModel,
      modelParams,
      defaultSystemMessage,
    };

    this.httpClientInstance = fetch;
    this.schemaValidator = responseSchema;
  }

  /**
   * Sends a chat completion request to OpenRouter API
   */
  public async sendChatCompletion(request: ChatCompletionRequest): Promise<ChatCompletionResponse> {
    try {
      const payload = this.buildRequestPayload(request);

      const response = await this.httpClientInstance(this.openRouterConfig.baseURL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.openRouterConfig.apiKey}`,
          "HTTP-Referer": typeof window !== "undefined" ? window.location.origin : "https://toADHDo.app",
          "X-Title": "toADHDo",
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new APIError(`OpenRouter API error: ${response.statusText}`, response.status, errorData);
      }

      const data = await response.json();
      return this.parseResponse(data);
    } catch (error: unknown) {
      if (error instanceof APIError || error instanceof ValidationError) {
        throw error;
      }

      if (error instanceof TypeError || (error instanceof Error && error.message?.includes("network"))) {
        throw new NetworkError("Network error when connecting to OpenRouter API", error);
      }

      if (error instanceof Error && (error.name === "AbortError" || error.message?.includes("timeout"))) {
        throw new TimeoutError("Request to OpenRouter API timed out");
      }

      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error while sending chat completion: ${errorMessage}`);
    }
  }

  /**
   * Builds the request payload from the chat completion request
   */
  private buildRequestPayload(request: ChatCompletionRequest): RequestPayload {
    const { userMessage, systemMessage, modelParams, model } = request;

    if (!userMessage || typeof userMessage !== "string") {
      throw new ValidationError("User message is required and must be a string");
    }

    const messages = [
      {
        role: "system" as const,
        content: systemMessage || this.openRouterConfig.defaultSystemMessage,
      },
      {
        role: "user" as const,
        content: userMessage,
      },
    ];

    // Create base payload
    const payload: RequestPayload = {
      model: model || this.openRouterConfig.defaultModel,
      messages,
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "TODO",
          strict: true,
          schema: {
            type: "object",
            properties: {
              text: {
                type: "string",
                description: "Text content generated by the AI",
              },
              tags: {
                type: "array",
                description: "List of tags detected by the AI",
                items: {
                  type: "string",
                },
              },
            },
            required: ["text", "tags"],
            additionalProperties: false,
          },
        },
      },
    };

    // Add model parameters if provided
    const finalModelParams = { ...this.openRouterConfig.modelParams, ...modelParams };

    if (finalModelParams.temperature !== undefined) {
      payload.temperature = finalModelParams.temperature;
    }

    if (finalModelParams.max_tokens !== undefined) {
      payload.max_tokens = finalModelParams.max_tokens;
    }

    if (finalModelParams.top_p !== undefined) {
      payload.top_p = finalModelParams.top_p;
    }

    if (finalModelParams.frequency_penalty !== undefined) {
      payload.frequency_penalty = finalModelParams.frequency_penalty;
    }

    if (finalModelParams.presence_penalty !== undefined) {
      payload.presence_penalty = finalModelParams.presence_penalty;
    }

    return payload;
  }

  /**
   * Parses and validates the API response
   */
  private parseResponse(response: unknown): ChatCompletionResponse {
    if (
      !response ||
      typeof response !== "object" ||
      !("choices" in response) ||
      !Array.isArray(response.choices) ||
      !response.choices[0] ||
      typeof response.choices[0] !== "object" ||
      !("message" in response.choices[0])
    ) {
      throw new ValidationError("Invalid response format from OpenRouter API", response as Record<string, unknown>);
    }

    try {
      const message = response.choices[0].message;
      if (typeof message !== "object" || !message || !("content" in message)) {
        throw new ValidationError("Invalid message format in OpenRouter response", response as Record<string, unknown>);
      }

      const content = message.content;

      // Parse JSON content
      let parsedContent: unknown;
      try {
        parsedContent = typeof content === "string" ? JSON.parse(content) : content;
      } catch {
        throw new ValidationError("Failed to parse JSON response", { content } as Record<string, unknown>);
      }

      // Validate with zod schema
      const validationResult = this.schemaValidator.safeParse(parsedContent);

      if (!validationResult.success) {
        throw new ValidationError("Response does not match expected schema", {
          received: parsedContent,
          errors: validationResult.error,
        } as Record<string, unknown>);
      }

      return validationResult.data;
    } catch (error: unknown) {
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new ValidationError(`Error parsing response: ${error instanceof Error ? error.message : String(error)}`, {
        response,
      } as Record<string, unknown>);
    }
  }
}
